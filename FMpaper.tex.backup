\documentclass[letter]{llncs}

\newcommand{\figshrink}{\vspace{-.6cm}}
%\newcommand{\figshrinkend}{\vspace{-.4cm}}
\newcommand{\figshrinkend}{}
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{url}
\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas,
frank.holzwarth,|
\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|  
\newcommand{\Tr}{\ensuremath{\mathsf{TrS}}}
\newcommand{\TrR}{\ensuremath{\mathsf{TrR}}}
\newcommand{\TrA}{\ensuremath{\mathsf{Cond}}}
\renewcommand{\a}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\concat}{\ensuremath{\mathop{+\!\!+}}}
\documentclass[letter]{llncs}
\newcommand{\figshrink}{\vspace{-.6cm}}
%\newcommand{\figshrinkend}{\vspace{-.4cm}}
\newcommand{\figshrinkend}{}
\newcommand{\secshrink}{\vspace{-.5cm}}
\newcommand{\secshrinkbegin}{\vspace{-.2cm}}
\newcommand{\subsecshrink}{\vspace{-.5cm}}
\newcommand{\subsecshrinkbegin}{\vspace{-.2cm}}
\setlength{\abovecaptionskip}{1ex}
\setlength{\belowcaptionskip}{1ex}
\setlength{\floatsep}{1ex}
\setlength{\textfloatsep}{1ex}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{amsmath}
% \usepackage[options]{algorithm2e}
% \usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\usepackage{algorithm}

\makeatletter
\renewcommand{\ALG@beginalgorithmic}{\small}
\algrenewcommand\algorithmicindent{0.5em}%
\makeatother
\usepackage[caption=false,font=footnotesize]{subfig}
\usepackage{url}
\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas,
frank.holzwarth,|
\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|  
\usepackage{listings}
\usepackage{enumerate}
\usepackage{textcomp}
\usepackage{times}
\DeclareMathSizes{10}{10}{9}{9}
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx

\begin{document}

\title{Property Specification Made Easy: Harnessing the Power of Model Checking in UML designs}

\author{Daniela Remenska\inst{1,3}
\and Tim A.C. Willemse\inst{2} \and Jeff Templon\inst{3} \and\
Kees Verstoep\inst{1} \and Henri Bal\inst{1}}
%
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Dept. of Computer Science, VU University Amsterdam, The Netherlands
\and
Dept. of Computer Science, TU Eindhoven, The Netherlands
\and
NIKHEF, Amsterdam, The Netherlands
}

\toctitle{Lecture Notes in Computer Science}
\tocauthor{Authors' Instructions}
\maketitle

\begin{abstract}
One of the challenges in concurrent software development is early discovery of
design errors which could lead to deadlocks or race-conditions. For safety-critical and
complex distributed applications, traditional testing does not always expose
such problems. Performing more rigorous formal
analysis typically requires a model, which is an abstraction of the system. For
object-oriented software, UML is the industry-adopted modeling
language. UML offers a number of views to present the system from different
perspectives. Behavioral views are necessary for the purpose of model checking,
as they capture the dynamics of the system. Among them are sequence diagrams, in
which the interaction between components is modeled by means of message
exchanges. UML 2.x includes rich features that
enable modeling code-like structures, such as loops, conditions and referring to
existing interactions.
We present an automatic procedure for translating UML into mCRL2 process algebra
models. Our prototype is able to
produce a formal model, and feed model-checking traces back into any
UML modeling tool, without the user having to leave the UML domain. We argue why
previous approaches of which we are aware have limitations that we overcome. We
further apply our methodology on the Grid framework used to support production
activities of one of the LHC experiments at CERN.
\keywords{property specification, model checking, UML, sequence diagrams, modal $\mu$-calculus, property patterns}
\end{abstract}
\section{Introduction}
\label{sec:Introduction}
One of the challenges in concurrent software development is early discovery of design errors which can lead to deadlocks or race-conditions.
Traditional testing does not always expose such problems in complex distributed applications. Performing more rigorous formal analysis, like model-checking, 
typically requires a model which is an abstraction of the system.
In the last decades, more rigorous methods and tools
for modeling and formal analysis have been developed. Some of the leading model checking tools include SPIN, nuSMV, CADP and mCRL2. 
Despite the research effort, these methods are still not widely accepted in industry. One problem is the lack of expertise and
the necessary time investment in the development cycle, for becoming proficient in
the underlying mathematical formalisms used for describing the models. A more substantial problem is the lack of a systematic connection between actual
implementation and the semantics of the existing formal languages.
To bridge the gap between industry-adopted methodologies based on UML software
designs, and model-checking tools and languages, in~\cite{DBLP:dblp_conf/nfm/RemenskaTWHVCB13} we devised 
an automated transformation methodology for verification of UML
models, based on sequence and activity diagrams. Our prototype is able to produce
a formal model into the mCRL2 process algebra language ~\cite{FormalLanguagemCRL2}, and feed model-checking traces back into any modeling
tool, without the user having to leave the UML domain. We chose mCRL2 because of its strong tool support and rich data types compared to other languages.
Figure~\ref{fig:approach} gives an overview of our approach and implemented toolchain.
Although the mCRL2 toolset automatically discovers deadlocks, model checking
for application-specific properties requires the use of modal $\mu$-calculus~\cite{Groote05model-checkingprocesses}. In principle, regardless of the formal language and tool choice for writing the model, these properties 
are specified as formulae in some temporal logic formalism, such as Linear Temporal Logic (LTL), Computation Tree Logic (CTL), Quantified Regular Expressions (QRE) or $\mu$-calculus.
\begin{figure}[!t]
\centering
\figshrink
\includegraphics[width=0.7\linewidth,keepaspectratio=true]{./Approach.png}
\caption{Automated verification of UML models}
\label{fig:approach}
\figshrinkend
\end{figure}
The level of sophistication and mathematical background required for using such formalisms is yet another obstacle for adopting formal methods. 
In practice, software requirements are written in natural language, and often contain ambiguities, making it difficult even for experienced 
practitioners to capture them accurately with temporal logic. There are subtle, but crucial details which are often overlooked and 
need to be carefully considered in order to distill the right formula.
The objective of this work is to simplify the process of correctly eliciting functional requirements, without the need of expertise in temporal logic. 

Based on investigation of more than 500 properties coming from different domains, and specified in several different formalisms, a pattern-based classification
was developed in~\cite{Dwyer:1999:PPS:302405.302672}. The authors observed that almost all the surveyed properties
can be mapped into one of several property patterns. Each pattern is a
high-level, formalism-independent, specification abstraction that captures a
commonly-occurring requirement. These patterns can be instantiated with specific
events or states and then mapped to several different formalisms for model
checking tools. Their hierarchical taxonomy is based on the idea that each
pattern has a \emph{scope}, which defines the extent of program execution over
which the pattern must hold and a \emph{behavior}, which describes the intent of the pattern. The pattern
system identifies 5 scopes and 8 behavior variations that can be
combined to create 40 different properties. Examples of scopes are: globally, before an event or state occurs, after an event or state occurs.
Examples of behavior variations are: absence (an event or state should never occur during an execution), precedence (which require that a given event or state always occurs before another one), 
or response properties (which require that the occurrence of a given event or state be followed by designated event or state), capturing a cause-effect relation.
Although the patterns website~\cite{PSP} contains a collection of templates for different target formalisms, such as LTL, CTL, Graphical Interval Logic (GIL) [], and Quantified Regular Expressions, (QRE), practitioners have to fully understand the provided solutions before they can select and apply the appropriate ones.

We have thoroughly surveyed the advantages and disadvantages of these approaches, and a more detailed comparison with our approach is given in Section~\ref{sec:RelatedWork}.
\section{Preliminaries}
\subsection{Property Patterns}

\subsection{Brief Introduction to mCRL2 and $\mu$-calculus}

\subsection{UML Sequence Diagrams}


\section{The Approach}
\subsection{The Rationale}
\subsection{Transforming a $\mu$-calculus Formula Into a Monitor Process} 
We translate a fragment of the $\mu$-calculus to mCRL2 processes which
can subsequently serve as monitor processes.

We restrict to the following grammar:
\[
\begin{array}{ll}
\phi_1 & ::= b \mid \forall d:D.\phi_1 \mid [R]\phi_1 \mid \phi_1\wedge \phi_2\\
R_1,R_2 & ::= \alpha \mid nil \mid R_1\cdot R_2 \mid
              R_1+R_2 \mid
              R_1^* \mid R_1^+ \\
\alpha_1,\alpha_2 & ::= b \mid \a{a(e)} \mid \neg \alpha_1 \mid
              \alpha_1 \wedge \alpha_2 \mid
              \exists d:D.\alpha_1
\end{array}
\]
Before we present the translation, we convert the formulae in
guarded form. That is, we remove every occurrence of $R^*$ and $nil$ using
the following rules:
\[
\begin{array}{ll}
~
[nil]\phi &= \phi \\
~[R^*]\phi &= [nil]\phi \wedge [R^+]\phi
\end{array}
\]
The function $\Tr$ takes two arguments (a formula and a list of typed
variables) and produces a process. It is defined inductively as follows:
\[
\begin{array}{ll}
\Tr_l(b) &= (\neg b \to \a{error}) \\
\Tr_l(\forall d:D.\phi_1) & = \sum d:D. \Tr_{l\concat [d:D]} (\phi_1) \\
\Tr_l(\phi_1 \wedge \phi_2) & = \Tr_l(\phi_1) + \Tr_l(\phi_2) \\
\Tr_l([R]\phi_1) & = \TrR_l(R) \cdot \Tr_l(\phi) \\
\end{array}
\]
where $\TrR$ takes a regular expression (and a list of typed variables)
and produces a process or a condition:
\[
\begin{array}{ll}
\TrR_l(\alpha) &= \bigoplus\limits_{a \in Act} (\sum d_a:D_a.~ \TrA_l(a(d_a),\alpha) \to a(d_a)) \\
\TrR_l(R_1 \cdot R_2) & = \TrR_l(R_1) \cdot \TrR_l(R_2) \\
\TrR_l(R_1 + R_2) &= \TrR_l(R_1) + \TrR_l(R_2) \\
\TrR_l(R_1^+) & = X(l) \qquad \textit{where $X(l) = \TrR_l(R_1)\cdot X(l)$ is
a recursive process} 
\end{array}
\]
where $\bigoplus$ is a finite summation over all action names
$a \in Act$ and
where $\TrA$ takes an action and an action formula and produces a condition
that describes when the action is among the set of actions described by
the action formula:
\[
\begin{array}{ll}
\TrA_l(a(d_a),b) & = b \\
\TrA_l(a(d_a),a'(e)) & = \left \{ \begin{array}{ll} d_a = e & \text{if a = a'}\\
                                  \text{false} & \text{otherwise}\\
                                  \end{array} \right .\\
\TrA_l(a(d_a),\neg \alpha_1) & = \neg \TrA_l(a(d_a),\alpha_1) \\
\TrA_l(a(d_a),\alpha_1 \wedge \alpha_2) & =
\TrA_l(a(d_a),\alpha_1) \wedge \TrA_l(a(d_a),\alpha_2) \\
\TrA_l(a(d_a),\exists d:D.\alpha_1) & = \exists d:D. \TrA_l(a(d_a),\alpha_1)
\end{array}
\]

\subsection{The Wizard} 
mention free drawing and the profile application 

\section{Case Study: DIRAC's Executor Framework revisited}

\section{Related Work}
\label{sec:RelatedWork}
\section{Conclusions and future work}
\bibliographystyle{splncs} 
\vspace{-8 pt}
\bibliography{FM2014}
\end{document}



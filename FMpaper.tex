\documentclass[letter]{llncs}


\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\usepackage{algorithm}
\usepackage{amsmath}
\newcommand{\Tr}{\ensuremath{\mathsf{TrS}}}
\newcommand{\TrR}{\ensuremath{\mathsf{TrR}}}
\newcommand{\TrA}{\ensuremath{\mathsf{Cond}}}
\renewcommand{\a}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\concat}{\ensuremath{\mathop{+\!\!+}}}
\begin{document}

\title{Property Specification Made Easy: Harnessing the Power of Model Checking in UML designs}

\author{Daniela Remenska\inst{1,3}
\and Tim A.C. Willemse\inst{2} \and Jeff Templon\inst{3} \and\
Kees Verstoep\inst{1} \and Henri Bal\inst{1}}
%
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Dept. of Computer Science, VU University Amsterdam, The Netherlands
\and
Dept. of Computer Science, TU Eindhoven, The Netherlands
\and
NIKHEF, Amsterdam, The Netherlands
}

\toctitle{Lecture Notes in Computer Science}
\tocauthor{Authors' Instructions}
\maketitle

\begin{abstract}
One of the challenges in concurrent software development is early discovery of
design errors which could lead to deadlocks or race-conditions. For safety-critical and
complex distributed applications, traditional testing does not always expose
such problems. Performing more rigorous formal
analysis typically requires a model, which is an abstraction of the system. For
object-oriented software, UML is the industry-adopted modeling
language. UML offers a number of views to present the system from different
perspectives. Behavioral views are necessary for the purpose of model checking,
as they capture the dynamics of the system. Among them are sequence diagrams, in
which the interaction between components is modeled by means of message
exchanges. UML 2.x includes rich features that
enable modeling code-like structures, such as loops, conditions and referring to
existing interactions.
We present an automatic procedure for translating UML into mCRL2 process algebra
models. Our prototype is able to
produce a formal model, and feed model-checking traces back into any
UML modeling tool, without the user having to leave the UML domain. We argue why
previous approaches of which we are aware have limitations that we overcome. We
further apply our methodology on the Grid framework used to support production
activities of one of the LHC experiments at CERN.
\keywords{property specification, model checking, UML, sequence diagrams, modal $\mu$-calculus, property patterns}
\end{abstract}
\section{Introduction}
\label{sec:Introduction}
As modern software systems become more complex and distributed, a major
challenge is faced 
in maintaining their quality and functional correctness. Early discovery of
design errors which could
lead to deadlocks, race-conditions and other flaws, before they can surface,
is of a paramount importance.
The Unified Modeling Language (UML) has become the lingua franca
of software engineering, in particular for the domain of object-oriented
systems. Over time, several mature CASE tools have already adopted UML as the
industry-standard visual modeling language for describing software systems. 
However, use of these tools alone does not
assure the correctness of the design, nor does it provide direct means to test
the software under design,
For safety-critical and
complex distributed applications, traditional testing does not always expose
such problems. Performing more rigorous formal
analysis typically requires a model, which is an abstraction of the system.
In the last decades, more rigorous methods and tools for modeling and analysis
 have been proposed. Despite the research effort,
these methods are still not widely
accepted in industry. One problem is the lack of expertise and the necessary
time investment in the OO development cycle, for becoming proficient in them. 
A more substantial problem is the lack of a systematic connection between 
actual implementation and the semantics of the existing formal languages. 

\section{Preliminaries}
\subsection{Property Patterns}

\subsection{Brief Introduction to mCRL2 and $\mu$-calculus}

\subsection{UML Sequence Diagrams}


\section{The Approach}
\subsection{The Rationale}
\subsection{Transforming a $\mu$-calculus Formula Into a Monitor Process} 
We translate a fragment of the $\mu$-calculus to mCRL2 processes which
can subsequently serve as monitor processes.

We restrict to the following grammar:
\[
\begin{array}{ll}
\phi_1 & ::= b \mid \forall d:D.\phi_1 \mid [R]\phi_1 \mid \phi_1\wedge \phi_2\\
R_1,R_2 & ::= \alpha \mid nil \mid R_1\cdot R_2 \mid
              R_1+R_2 \mid
              R_1^* \mid R_1^+ \\
\alpha_1,\alpha_2 & ::= b \mid \a{a(e)} \mid \neg \alpha_1 \mid
              \alpha_1 \wedge \alpha_2 \mid
              \exists d:D.\alpha_1
\end{array}
\]
Before we present the translation, we convert the formulae in
guarded form. That is, we remove every occurrence of $R^*$ and $nil$ using
the following rules:
\[
\begin{array}{ll}
~
[nil]\phi &= \phi \\
~[R^*]\phi &= [nil]\phi \wedge [R^+]\phi
\end{array}
\]
The function $\Tr$ takes two arguments (a formula and a list of typed
variables) and produces a process. It is defined inductively as follows:
\[
\begin{array}{ll}
\Tr_l(b) &= (\neg b \to \a{error}) \\
\Tr_l(\forall d:D.\phi_1) & = \sum d:D. \Tr_{l\concat [d:D]} (\phi_1) \\
\Tr_l(\phi_1 \wedge \phi_2) & = \Tr_l(\phi_1) + \Tr_l(\phi_2) \\
\Tr_l([R]\phi_1) & = \TrR_l(R) \cdot \Tr_l(\phi) \\
\end{array}
\]
where $\TrR$ takes a regular expression (and a list of typed variables)
and produces a process or a condition:
\[
\begin{array}{ll}
\TrR_l(\alpha) &= \bigoplus\limits_{a \in Act} (\sum d_a:D_a.~ \TrA_l(a(d_a),\alpha) \to a(d_a)) \\
\TrR_l(R_1 \cdot R_2) & = \TrR_l(R_1) \cdot \TrR_l(R_2) \\
\TrR_l(R_1 + R_2) &= \TrR_l(R_1) + \TrR_l(R_2) \\
\TrR_l(R_1^+) & = X(l) \qquad \textit{where $X(l) = \TrR_l(R_1)\cdot X(l)$ is
a recursive process} 
\end{array}
\]
where $\bigoplus$ is a finite summation over all action names
$a \in Act$ and
where $\TrA$ takes an action and an action formula and produces a condition
that describes when the action is among the set of actions described by
the action formula:
\[
\begin{array}{ll}
\TrA_l(a(d_a),b) & = b \\
\TrA_l(a(d_a),a'(e)) & = \left \{ \begin{array}{ll} d_a = e & \text{if a = a'}\\
                                  \text{false} & \text{otherwise}\\
                                  \end{array} \right .\\
\TrA_l(a(d_a),\neg \alpha_1) & = \neg \TrA_l(a(d_a),\alpha_1) \\
\TrA_l(a(d_a),\alpha_1 \wedge \alpha_2) & =
\TrA_l(a(d_a),\alpha_1) \wedge \TrA_l(a(d_a),\alpha_2) \\
\TrA_l(a(d_a),\exists d:D.\alpha_1) & = \exists d:D. \TrA_l(a(d_a),\alpha_1)
\end{array}
\]

\subsection{The Wizard} 
mention free drawing and the profile application 

\section{Case Study: DIRAC's Executor Framework revisited}

\section{Related Work}

\section{Conclusions and future work}
\end{document}



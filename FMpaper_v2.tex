\documentclass[letter]{llncs}
\usepackage{capt-of}

\newcommand{\figshrink}{\vspace{-.6cm}}
%\newcommand{\figshrinkend}{\vspace{-.4cm}}
\newcommand{\figshrinkend}{}
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{amsmath}

\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{url}
\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas,
frank.holzwarth,|
\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|  
\newcommand{\Tr}{\ensuremath{\mathsf{TrS}}}
\newcommand{\TrR}{\ensuremath{\mathsf{TrR}}}
\newcommand{\TrA}{\ensuremath{\mathsf{Cond}}}
\renewcommand{\a}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\concat}{\ensuremath{\mathop{+\!\!+}}}
%\newcommand{\figshrinkend}{\vspace{-.4cm}}
\newcommand{\secshrink}{\vspace{-.5cm}}
\newcommand{\secshrinkbegin}{\vspace{-.2cm}}
\newcommand{\subsecshrink}{\vspace{-.5cm}}
\newcommand{\subsecshrinkbegin}{\vspace{-.2cm}}
\setlength{\abovecaptionskip}{1ex}
\setlength{\belowcaptionskip}{1ex}
\setlength{\floatsep}{1ex}
\setlength{\textfloatsep}{1ex}
\usepackage{times}
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{amsmath}
% \usepackage[options]{algorithm2e}
% \usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\usepackage{algorithm}

\makeatletter
\renewcommand{\ALG@beginalgorithmic}{\small}
\algrenewcommand\algorithmicindent{0.5em}%
\makeatother
\usepackage[caption=false,font=footnotesize]{subfig}
\usepackage{url}
\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas,
frank.holzwarth,|
\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|  
\usepackage{listings}
\usepackage{enumerate}
\usepackage{textcomp}
\DeclareMathSizes{10}{10}{9}{9}
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx

\begin{document}

\title{Property Specification Made Easy: Harnessing the Power of Model Checking in UML designs}

\author{Daniela Remenska\inst{1,3}
\and Tim A.C. Willemse\inst{2} \and Jeff Templon\inst{3} \and\
Kees Verstoep\inst{1} \and Henri Bal\inst{1}}
%
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Dept. of Computer Science, VU University Amsterdam, The Netherlands
\and
Dept. of Computer Science, TU Eindhoven, The Netherlands
\and
NIKHEF, Amsterdam, The Netherlands
}

\toctitle{Lecture Notes in Computer Science}
\tocauthor{Authors' Instructions}
\maketitle
\vspace{-10 pt}

\begin{abstract}
Early discovery of design errors which can lead to deadlocks or race conditions is 
challenging in concurrent software development. 
In the last decades, more rigorous
methods and tools for modeling and formal analysis have been developed. 
Although approaches for automatically generating formal models from system designs have 
been proposed, another serious obstacle for adopting model checking tools in industry
is the formulation of application-specific properties to be checked. 
This requires expertise in temporal logic, regardless of the verification tool used.
To bring the process of correctly eliciting functional properties closer to software 
designers, we introduce PASS, a Property ASSistant wizard developed 
as an Eclipse plugin. Our starting point was the well-established property pattern system,
which we extended with new property templates, to capture variations not covered 
in the original classification. PASS instantiates pattern templates using three notations: a natural language summary, a $\mu$-calculus formula
and a UML sequence diagram depicting the desired behavior. Most approaches to date 
have focused on LTL, which is a state-based formalism. Conversely,
 $\mu$-calculus is event-based, making it a good match for sequence diagrams, where communication between
 components is depicted. 
Moreover, such communication is data-dependent, so we introduce
the possibility to define data quantifiers, to express complex properties in a concise manner.
To cope with state-space explosion, we provide one additional notation: a monitor for on-the-fly model checking, or bug hunting.
We revisit a case study from the Grid domain, using PASS to obtain the
formula and monitor for checking the property with mCRL2.
% \keywords{property specification, model checking, UML, sequence diagrams, modal
% $\mu$-calculus, property patterns}
\end{abstract}
\section{Introduction}
\vspace{-8 pt}

\label{sec:Introduction}
One of the challenges in developing concurrent software is early discovery of design errors which can lead to deadlocks or race conditions.
Traditional testing does not always expose such problems in complex distributed applications. Performing a more rigorous formal analysis, like model checking, 
typically requires a model which is an abstraction of the system.
In the last decades, methods and tools
for modeling and formal analysis have been developed. Some of the leading model checking tools include SPIN, nuSMV, CADP and mCRL2. 
Despite the research effort, these tools are still not widely accepted in the software industry. One problem is the lack of expertise and
the necessary time investment in the development cycle, for becoming proficient in
the underlying mathematical formalisms used for describing the models. 
To bridge the gap between industry-adopted methodologies based on UML software
designs, and model checking tools and languages, in~\cite{DBLP:dblp_conf/nfm/RemenskaTWHVCB13} we devised 
an automated transformation methodology for verifying UML
models, based on sequence and activity diagrams. Figure~\ref{fig:approach} gives an overview of our approach and implemented toolchain. 
Our prototype is able to produce
a formal model into the mCRL2 process algebra language~\cite{FormalLanguagemCRL2}, and feed model checking traces back into any modeling
tool, without the user having to leave the UML domain. 
We chose mCRL2 because of its strong tool support and rich data types compared to other languages.
%mention why we chose SDs!

Although the mCRL2 toolset automatically discovers deadlocks, model checking
of application-specific properties relies on using the modal $\mu$-calculus~\cite{Groote05model-checkingprocesses} for expressing these properties. In principle, regardless of the formal language and tool choice for writing the model, these properties 
are specified as formulas in some temporal logic formalism, such as Linear Temporal Logic (LTL), Computation Tree Logic (CTL), Quantified Regular Expressions (QRE) or $\mu$-calculus.
\begin{figure}[!t]
\centering
\figshrink
\includegraphics[width=0.7\linewidth,keepaspectratio=true]{./Approach.png}
\caption{Automated verification of UML models}
\label{fig:approach}
\figshrinkend
\end{figure}
The level of sophistication and mathematical background required for using such formalisms is yet another obstacle for adopting formal methods. 
In practice, software requirements are written in natural language, and often contain ambiguities, making it difficult even for experienced 
practitioners to capture them accurately with temporal logic. There are subtle, but crucial details which are often overlooked and 
need to be carefully considered in order to distil the right formula.

% just mention here the patterns, the fact that there are 3 categories of approaches
% tackling the problem, the general deficiencies of these approaches and how we want to
% take the best of all worlds; 
Based on investigating over 500 properties coming from different domains, and specified in several formalisms, a pattern-based classification
was developed in~\cite{Dwyer:1999:PPS:302405.302672}. The authors observed that almost all the surveyed properties
can be mapped into one of several property patterns. Each pattern is a
high-level, formalism-independent abstraction that captures a
commonly occurring requirement. These patterns can be instantiated with specific
events or states and then mapped to several different formalisms for model
checking tools. Their hierarchical taxonomy is based on the idea that each
pattern has a \emph{scope}, which defines the extent of program execution over
which the pattern must hold, and a \emph{behavior}, which describes the intent of the pattern. The pattern
system identifies 5 scopes and 11 behavior variations that can be
combined to create 55 different property templates. Examples of scopes are: globally,
before an event or state occurs, after an event or state occurs.
Examples of behavior classification are: absence (an event or state should never
occur during an execution), precedence (an event or
state always occurs before another one), 
or response (the occurrence of a an event or state must be followed by
another event or state), capturing a cause-effect relation.
Although the patterns website~\cite{PSP} contains a collection of mappings for
different target formalisms, such as LTL, CTL, QRE and Graphical Interval Logic, which can be considered helpful,
practitioners have to fully understand the provided solutions before they can
select and apply the appropriate ones in practice.
\vspace{1.5 pt}

To mitigate the above problem, several approaches~\cite{Smith02propel:an,konrad2005facilitating,Mondragon_prospec} propose conversational tools for
elucidating properties, based on the property patterns. These tools guide users in selecting the appropriate pattern
for the property in mind, and optionally produce a formula in some target temporal logic. 
Another category of approaches~\cite{Ziemann02anextension,Flake03formalsemantics,Ackermann:2006:LOS:2135315.2135339} deal with temporal extensions 
of the Object Constraint Language (OCL), as means to specify system
properties. OCL is a declarative textual language for describing invariants for
classes and pre- and postconditions of operations. Although it forms an integral
part of UML, it lacks the means to specify constraints over the dynamic behavior
of a model. Finally, a third class of approaches~\cite{Autili:2007:GSS:1290845.1290859,Lee97agraphical,Smith:2001:ECG:882477.883639,Knapp:2006:MCU:1762828.1762836,Lilius99vuml:a,Kugler:2005:TLS:2140653.2140692,MVPSA} tackle the property
specification problem by proposing graphical notations for specifying properties.

The objective of our work is to simplify the process of correctly eliciting
functional requirements, without the need of expertise in temporal logic. 
First, we introduce PASS, a Property ASSistant which guides and facilitates the process of deriving
system properties. Our starting point was the pattern system~\cite{Dwyer:1999:PPS:302405.302672},
which we extended with over 100 new property templates, to capture variations not covered 
in the original classification. Our strong motivation was to stay
in the same UML development environment, rather than use an external helper tool for this.
It should increase the tool accessibility by allowing software engineers to remain focused in the realm of UML designs.
In addition, a tight bond between elements of the design and instances of the property template is kept, such that, if the 
design is changed, these changes can be easily propagated in the property template placeholders. 
To this end, we use the standard MDT-UML2~\cite{MDTUML2} Eclipse modeling API. Our tool is developed as an Eclipse plugin.
Second, the pattern templates instantiated with PASS have three notations: a natural language summary, a $\mu$-calculus formula
and a UML sequence diagram depicting the desired behavior. Most approaches to date 
have focused on LTL, which is a state-based temporal logic formalism. Conversely,
the $\mu$-calculus is event-based, and as such is a good match for the sequence diagrams notation. 
These events can represent methods calls or asynchronous communication between distributed components.
Moreover, such communication is data-dependent, which is why we introduce
the possibility to define quantifiers, to express complex properties in a concise manner, e.g., every
element of a certain type must fulfil a certain property. 
Unlike LTL or CTL,  the $\mu$-calculus is powerful enough
to achieve this in a natural way. Third, to cope with state-space explosion,
we provide one additional automatically-generated notation: a monitor for on-the-fly model checking, or bug hunting.
We interpret a sequence diagram as an observer of the message exchanges in the system.
This helps to avoid exploring irrelevant parts of the state space. The state space
generation is thus property driven, and stops as soon as an error is found.
Finally, we revisit a case study we did previously in~\cite{DBLP:dblp_conf/nfm/RemenskaTWHVCB13}, this time
using the PASS tool to automatically obtain the formula and monitor for checking the property in mCRL2.

This paper is structured as follows: in Section~\ref{sec:RelatedWork} we
 survey the most relevant related approaches,
and outline their advantages and shortcomings. Section~\ref{sec:Preliminaries} briefly introduces the
syntax and semantics of mCRL2, $\mu$-calculus and UML sequence diagrams.
We describe our approach in Section~\ref{sec:Approach}.
In Section~\ref{sec:CaseStudy} we apply PASS on a case study from the Grid domain, and we conclude in Section~\ref{sec:Conclusions}.
\vspace{-10 pt}

\section{Related Work}
\vspace{-7 pt}

\label{sec:RelatedWork}
In~\cite{Smith02propel:an} the authors developed PROPEL, a tool for guiding users in 
selecting the appropriate template from the patterns classification. Recognizing that there are subtle aspects
not covered by the original patterns, such as what happens in a response
property if the cause occurs multiple times before the effect takes place,
they extended them with variants. The resulting templates 
are represented using ``disciplined natural language'' and finite state automata. 
PROPEL does not support the universality, bounded existence, and the chain patterns. It also 
does not produce a formula in any of the commonly used temporal logic formalisms.
In a similar manner, SPIDER~\cite{konrad2005facilitating} and 
Prospec~\cite{Mondragon_prospec} offer assistance in the specification process, and extend the original patterns
with compositional ones that are built up from combinations of more basic patterns. 
Unfortunately, we could not find SPIDER online, and the latest version of Prospec that we found and tested (Fig.~\ref{fig:Approaches} left) produces only 
formulas in Future Interval Logic, not LTL as stated in the work.

Of the approaches that deal with temporal extensions of OCL,~\cite{Ziemann02anextension}
introduces the @pre and @next temporal modifiers for specification of past and future state-oriented constraints. 
By means of UML Profiles,~\cite{Flake03formalsemantics}
proposes another OCL extension for real-time constraints. They claim to be able to describe all the existing 
patterns in these OCL expressions. Their starting point for model descriptions are UML state machines.
To simplify constraint definition with OCL, in~\cite{Ackermann:2006:LOS:2135315.2135339} the authors 
propose to use specification patterns for which OCL constraints can be generated automatically.
The behavioral specification of software components refers to interface specifications,
which are not really dynamic views. This work does not yet introduce means to specify temporal properties.
Resembling an OO programming language, OCL constraints can become quite dense and cryptic, and editing 
them manually is error-prone. Another problem is the extent to which designers are familiar with this language.
\begin{figure*}[t!]
  \centering
  \subfloat{\label{fig:Prospec}\includegraphics[width=0.73\linewidth]{./Prospec.png}}    
  \hfill
  \subfloat{\label{fig:Charmy}\includegraphics[width =0.26\linewidth]{./Charmy.png}}
  \caption{Left: Prospec tool; right: CHARMY PSC graphical notation}
  \label{fig:Approaches}
\end{figure*}

Graphical notation approaches come closest to the realm of modeling the system behavior.
%closest to our work...
The CHARMY approach~\cite{Autili:2007:GSS:1290845.1290859} presents a scenario-based visual language called 
Property Sequence Charts (PSC), where a property is seen as a relation on a set of exchanged
system messages. The language borrows concepts from UML 2.0 Sequence Diagrams, and its expressiveness
is measured with the property patterns. SPIN is used as a backend for model checking of
the B\"uchi automata~\cite{Giannakopoulou:2001:AVT:872023.872506}, which are 
an operational representation for LTL formulas generated automatically with this approach.
The PSC notation uses textual restrictions for past and future events, placed as circles directly on the message arrows (Fig.~\ref{fig:Approaches} right).
Such a mix of textual and visual representation of message communication
within a diagram can be error-prone. Additionally, asynchronous communication is not supported.
Furthermore, even though concepts from UML are borrowed, CHARMY is a standalone framework for architectural descriptions,
not inter-operable with UML tools, and as such its use in industrial contexts is limited.
Another graphical language is proposed in~\cite{Lee97agraphical}, where formulas
are represented as acyclic graphs of states and temporal operators as nodes.
While they manage to hide the formalism from the user by generating LTL formulas, 
their notation is still very close to an actual temporal logic formula.
The TimeLine Editor~\cite{Smith:2001:ECG:882477.883639} also attempts to simplify the formalization of certain
kinds of requirements. Response formulas are depicted in timeline diagrams by specifying temporal relations among events and constraints. 
The timeline specification is automatically converted into a B\"uchi automaton, amenable to model checking with SPIN.
Unfortunately the tool is no longer available.
HUGO/RT~\cite{Knapp:2006:MCU:1762828.1762836} is a tool for model checking UML 2.0 interactions 
against a model composed of message-exchanging state machines. The interactions represent the desired properties,
and are translated together with the system model into B\"uchi automata for model checking with SPIN.
The approach uses some inner format for textual representation of UML interactions (rather than
the standard XMI), and the version we tested does not support asynchronous messages, or combined fragments.
vUML~\cite{Lilius99vuml:a} is a tool for automatic verification of UML models comprising state machines.
However, properties must be specified in terms of undesired scenarios, which is not always convenient.
This is because the verification is based on checking whether it is possible to reach error states, which must be manually specified by the user.
Live Sequence Charts (LSC) are also used~\cite{Kugler:2005:TLS:2140653.2140692,MVPSA} as a graphical formalism for expressing behavioral properties.
Their elements allow to distinguish between possible (cold) and mandatory (hot) behavior.
In both approaches, B\"uchi automata and LTL formulas are generated automatically from the diagrams.
However, UML 2.0 sequence diagrams already borrow many concepts from LSC, by introducing the \emph{assert} and \emph{negate} fragments
to capture mandatory and forbidden behavior. On the other hand, being an older graphical notation, LSC lacks many UML features.
\vspace{-7 pt}

\section{Preliminaries}

\label{sec:Preliminaries}
%\subsection{Property Patterns}
\vspace{-7 pt}

\subsection{Brief Introduction to mCRL2 and $\mu$-calculus}
mCRL2 is a language and accompanying toolset for specifying and analyzing concurrent systems. 
Our choice for using the mCRL2 language is motivated by its rich set of 
abstract data types as first-class citizens, as well as its powerful toolset for analyzing, simulating, and visualizing specifications. 
The fragment of the mCRL2 syntax that is most commonly used is given by the following BNF grammar:
%\vspace{-7 pt}
\[p ::= a(d_1,\dots,d_n) \mid \tau \mid \delta \mid p+p \mid p\cdot p \mid p||p \mid \sum\nolimits_{d:D}p \mid c\rightarrow p\diamond p \mid \nabla_H(p) \mid \Gamma_C(p)
\]
Actions are the basic ingredients for models. They represent some observable
atomic event. An action $a$ of a process may have a number of data arguments  \begin{math}d_1,...,d_n\end{math}.
The action ${\tau}$ denotes an internal step, which cannot be observed from the external world. 
Non-deterministic choice between two processes
is denoted by the ``$+$'' operator. Processes can be composed sequentially and in parallel by means of ``$\cdot$'' and
``${||}$''. The sum
operator $\sum_{d:D}p$ denotes (possibly infinite) choice among
processes parameterized by variable $d$. The behavior of the conditional process $c\rightarrow p\diamond p$ 
depends on the value of the boolean expression $c$: if it evaluates to true, process $p$
is chosen and otherwise process $q$ is chosen.
This allows for modeling systems whose behavior is data-dependent.

To enforce synchronization between processes, the allow operator ${\nabla_H(p)}$ specifies the set of actions $H$ that are allowed
to occur. To show possible communications in a system and the resulting actions, the communication operator
${\Gamma_C(p)}$ is used. The elements of set $C$ are so-called multi-actions of the form $a_1\ |\ a_2\ |\ \dots |\ a_n \rightarrow c$, which intuitively
means that action $c$ is the result of the multi-party synchronization of actions $a_1 , a_2 , \dots $ and $a_n$.
There are a number of built-in data types in mCRL2, such as (unbounded) integers, (uncountable)
reals, booleans, lists, and sets. 
Furthermore, by a \textbf{sort} definition one can define a new data type. Recursive process 
equations can be declared by \textbf{proc}.

The semantics associated with the mCRL2 syntax is a Labeled Transition System (LTS)
system that has multi-action labeled transitions, which can carry data parameters. The language used by the mCRL2
toolset for model checking specific properties is an extension of the modal
$\mu$-calculus~\cite{Emerson97modelchecking}. This formalism stands out from most modal and temporal logic formalisms with respect to its
expressive power. Temporal logics like LTL, CTL and CTL* all have translations~\cite{cranen2010linear,cranen2011linear} into $\mu$-calculus,
witnessing its generality. This expressiveness comes at a cost: very complex formulas with no intuitive and apparent interpretation can be coined. 
The syntax of mCRL2's modal $\mu$-calculus formulas we are concerned with in this paper
is defined by the following grammar:
\[
\begin{array}{ll}
\phi & ::= b \mid \phi\wedge\phi \mid \phi\vee\phi \mid \forall d{:}D.~\phi \mid \exists d{:}D.~\phi
\mid [\rho]\phi \mid \langle\rho\rangle\phi \mid \mu Z\ldotp\phi(Z) \mid \nu Z\ldotp\phi(Z) \\
\rho & ::= \alpha \mid nil \mid \rho\cdot\rho \mid \rho^* \mid \rho^+ \\
\alpha & ::= a(d_1,\dots,d_n) \mid b \mid \neg \alpha \mid \alpha\cap\alpha \mid 
\alpha\cup\alpha \mid \bigcap{d{:}D}.~\alpha \mid \bigcup{d{:}D}.~\alpha \\
\end{array}
\]
Properties are expressed by state formulas $\phi$, which contain
Boolean data terms $b$ that evaluate to true or false and which can contain data variables, and the
standard logical connectives \emph{and} ($\land$) and \emph{or}
($\lor$), the modal operators \emph{must} ($[\_]\_$) and \emph{may}
($\langle \_\rangle\_$), and the least and greatest fixpoint operators
$\mu$ and $\nu$. In addition to these, mCRL2's extensions add universal
and existential quantifiers $\forall$ and $\exists$.

The modal operators take regular expressions
$\rho$ for describing words of actions, built up from the empty word $nil$, individual
actions described by an action formula $\alpha$, word
concatenation $\rho \cdot \rho$ and (arbitrary) iteration of words $\rho^*$ and $\rho^+$.
Action formulas describe sets of actions; these sets are built up from the empty
set of actions (in case Boolean expression $b$ evaluates to false), the set of all possible actions
(in case Boolean expression $b$ evaluates to true); indivual actions $a(d_1,\dots,d_n)$, 
action complementation and finite and possibly infinite intersection $\cap$ and union $\cup$.
A state of an LTS (described by an mCRL2 process) satisfies $\langle \rho \rangle \phi$
iff from that state, there is at least one transition sequence matching $\rho$,
leading to a state satisfying $\phi$;
$[\rho]\phi$ is satisfied by a state iff all transition sequences matching $\rho$ starting in that 
state lead to states satisfying $\phi$.
For instance, $[\neg (\bigcup{n{:}Nat}.~
\textit{read}(n+n))]\text{false}$ states that a process should not execute any actions
other than read actions with even-valued natural numbers.
Remember that $[a]\phi$ is trivially satisfied in states with no ``\emph{a}''-transitions.

Combining these modalities, the least ($\mu X\ldotp \phi(X)$) and
greatest ($\nu X\ldotp \phi(X)$) fixpoints permit reasoning about finite
and infinite runs of a system in a recursion-like manner.  For example,
we can read $\mu X\ldotp\phi\vee\langle\alpha\rangle X$ as: $X$ is
the smallest set of states such that a state is in $X$ iff $\phi$
holds in that state \emph{or} there is an $\alpha$-successor in $X$.
On the other hand, $\nu X\ldotp\phi \wedge[\alpha]X$ is the largest
set of states such that a state is in $X$ iff $\phi$ holds in that
state and all of its $\alpha$-successors are in $X$, too.  Finally, a
strong asset of mCRL2's $\mu$-calculus are the universal $\forall$ and
existential $\exists$ quantifiers over potentially infinite data types.
For example, $\forall n{:}Nat. \langle \textit{read}(n) \rangle \text{true}$
asserts that a process can execute a \emph{read} action, accepting every
natural number as a parameter.

In mCRL2, verification of $\mu$-calculus formulas is conducted using tooling that operates
on systems of fixpoint equations over first-order logic expressions.
This sometimes requires too much overhead to serve as a basis for lightweight 
bug-hunting, as it can be difficult to interpret the counterexamples that are obtained from
these equation systems in terms of the original mCRL2 process.
Observers, or monitors (\`{a} la B\"uchi) defined in the mCRL2 model itself, can sometimes
be used to bypass the problem.
However, not all $\mu$-calculus formulas are amenable to such a conversion.
\vspace{-10 pt}

\subsection{UML Sequence Diagrams}
\vspace{-7 pt}

Sequence diagrams model the interaction among a set of components, with
emphasis on the sequence of \emph{messages} exchanged over time. Graphically, they have
two dimensions: the objects participating in the scenarios are placed horizontally, 
while time flows in the vertical dimension. The participants are shown as rectangular boxes, with the vertical lines
falling from them known as \emph{lifelines}. 
Each message sent between the lifelines defines a specific act of communication, synchronous or asynchronous.
Messages are shown as horizontal arrows from the lifeline of the sender instance to the lifeline of the receiver. 

Sequence diagrams have been considerably extended in UML 2.x to allow expressing of complex control 
flows such as branching, iterations, and referring to existing interactions.
\textbf{Combined fragments} are used for this purpose. The specification
supports different fragment types, with operators such as \emph{alt, opt, loop, break, par}. They are
visualized as rectangles with a keyword indicating the type.
Each combined fragment consists of one or more interaction operands. Depending
on the type of the fragment, constraints can guard each of the interaction operands. 
Combined fragments can be nested with an arbitrary nesting
depth, to capture complex workflows. Figure~\ref{fig:SDExample} shows how some of them can be
used. 
\begin{figure}[!t]
\centering
\includegraphics[width=1.0\linewidth,keepaspectratio=true]{./Figure2_merged.png}
\caption{Sequence diagrams with combined fragments}
\label{fig:SDExample}
\end{figure}

There are also two less-known combined fragments: \emph{assert} and \emph{neg}. Their use in practice
is limited, because their semantics described in the UML 2.0 superstructure specification~\cite{UML2.4_superstructure}
is rather vague and confusing. By default, sequence diagrams without the use of these two operators 
only reflect possible behavior, while \emph{assert} and \emph{neg} alter the way 
a trace can be classified as valid or invalid. The specification characterizes
the semantics of a sequence diagram as a pair of valid and invalid traces,
where a trace is a sequence of events or messages.
The potential problems with the UML 2.0 assertion and negation are explained in~\cite{Harel07assertand}.
In summary, the specification aims to allow depicting required and forbidden behaviors.
However, as~\cite{Harel07assertand} points out, stating that ``the sequences of the operand of the assertion are the only valid continuations. All other continuations result in an invalid trace''
suggests that the invalid set of traces for an \emph{assert} fragment is its complement, i.e., the set of all other possible traces.
On the other hand, the standard declares that the
invalid set of traces are associated only with the use of
a \emph{neg} fragment, which is contradictory.
For this reason, we also believe that these two operators should rather be considered 
as modalities. We restrict their usage to single events in property specifications, and assign the following semantics:
\emph{neg} is considered a set-complement operator for the event captured by the fragment, while \emph{assert}
specifies that an event must occur. In addition, we
disallow nestings between these two fragments.
We find that this does not limit the expressiveness of property specifications in practice.
% I cannot find a counter-example where it would
\vspace{-7 pt}
\section{The Approach}
\label{sec:Approach}
\vspace{-5 pt}

\subsection{The Rationale}
To describe our proposal to a correct and straightforward property elucidation,
we outline the motivations behind the choices we made, and how they differ from
existing related approaches. As already stated, to bridge the gap between everyday practical software 
requirements specification and the the property patterns classification,
several conversational tools have already been proposed. 

While we follow 
on the idea of using a guiding questionnaire to incrementally refine various aspects
of a requirement, we find the resulting artifacts (LTL formulas or graphical representations of finite state machines) from using the available ones 
(discussed in Section~\ref{sec:RelatedWork}) not yet suitable for practical application in our context.
For one, the practitioner must manually define the events to be associated with the placeholders when 
instantiating the template. To avoid potential errors, as well as
reduce effort in specifications, we want to ideally stay in the same IDE used
for modeling the system, and select only existing events that represent
valid communication between components.  
In addition, we can already obtain~\cite{DBLP:dblp_conf/nfm/RemenskaTWHVCB13} mCRL2 models from UML designs comprising sequence diagrams.
In our experience, visual scenarios are the most suitable and commonly used  
means to specify the dynamics of a system. 
We believe that such a visual depiction of a scenario, more than finite state machines, 
improves the practitioner's understanding of the requirement as well. 
This is why we chose sequence diagrams as a property specification artifact too.

Most of the invented notations used by existing scenario approaches can fit well in UML 2.0 sequence diagrams.
Profiles are a standard way to extend UML for expressing concepts not included in the official metamodel. 
In short, UML profiles consist of stereotypes that can be applied to any UML model, like classes,
associations, or messages. We used this mechanism 
to apply the restrictions on the usage of \emph{neg} and \emph{assert},
as well as to distinguish between events presenting interval bounds and regular ones, from the patterns.
As an example, Fig.~\ref{fig:ResponsePattern} depicts the \emph{precedence chain} pattern (with
a \emph{between-Q-and-R} scope), with the stereotypes applied to messages
\emph{Q} and \emph{R}.
The pattern expresses that event \emph{P} must precede the chain of events
\emph{S, T}, always when the system execution is in the scope between events
\emph{Q} and \emph{R}.
We find this a much more intuitive scenario representation than the CHARMY/PSC
one (Fig.~\ref{fig:ResponsePatternCharmy}), for the same pattern.
Notice that we do not have to specify constraints on past unwanted events, as they are automatically
reflected in the $\mu$-calculus formula, as long as there is a distinction between interval-marking messages,
regular, mandatory, and forbidden ones. Also, the CHARMY/PSC notation presents the scenario in a negative form, using ``f:'' to
explicitly mark an error message. 
\begin{figure*}[t!]
  \centering
  \subfloat[Sequence Diagram with monitor]{\label{fig:ResponsePattern}\includegraphics[width=0.62\linewidth]{./ResponseChain_withMonitor1.png}}    
  \hfill
  \subfloat[PSC with B\"uchi automaton~\cite{Autili:2007:GSS:1290845.1290859}]{\label{fig:ResponsePatternCharmy}\includegraphics[width =0.38\linewidth]{./ResponseChainPSC.png}}
  \caption{Scenarios for the precedence chain pattern}
\end{figure*}
Although any mature visual UML modeling tool 
can be used, we chose IBM's RSA environment~\cite{terry2006visual}.
One of the advantages is that RSA is built on top of Eclipse, making 
it relatively easy to extend the functionality. To this end, PASS is developed as an Eclipse plugin, using the 
lightweight UML profile, and as such is available (Fig.~\ref{fig:PASSlaunch}) to any Eclipse-based UML tool.

Furthermore, most visual scenario approaches cover the (state-based) LTL mappings and extensions of the pattern system. 
Event-based temporal logics have not received much attention. Even though the original pattern 
system does not cover $\mu$-calculus, such mappings~\cite{RAFMC} have been developed by the CADP team.
However, there are no pattern extensions available. These are adequate for action- or event-based systems,
making them a good match for sequence diagrams, where communication between components is depicted.
LTL logic is interpreted over Kripke structures, where the states are labeled with elementary 
propositions that hold in each state, while $\mu$-calculus is interpreted over LTS, in which the transitions
are labeled with actions that represent state changes.
Even though both are complementary representations of the more general finite state automata, 
conversions between them are not practical, as they usually lead to a significant state space increase. 
For example, the fact that a lock has
been acquired or released can be naturally expressed by actions. Since state-based
temporal logics lack this mechanism, an alternative is to introduce a variable to indicate
the status of the lock, i.e., expose the state information. With such properties, LTS
representations are more intuitive, and easier to query using event-based logics.

Given that communication among components proceeds via actions (or events) which can
represent synchronous or asynchronous communication, property specification
can be defined over sequences of actions that are data-dependent.
Fortunately, $\mu$-calculus is rich enough to express both state and action formulas,
and provides means for quantification over data, which other formalisms lack. 
%maybe this can go to the questionnaire?
For example, with our approach, a practitioner can use 
a wild-card ``*'' to express that the property should be evaluated for all values
that message parameters can carry. This allows us to use patterns which would otherwise
make sense only for state-based formalisms. For example, the \emph{universality}
pattern is used to describe a portion of the system's execution which contains only states/events that have a desired property.
Checking if a certain event is executed in every step of the system execution is not useful,
so we adapted it in the context of $\mu$-calculus. 

Finally, for the purpose of on-the-fly verification, we provide an
automatically generated mCRL2 monitor which corresponds to the property formula.
We interpret a sequence diagram as an observer of
the message exchanges in the system. This helps in avoiding generation of those
parts of the state space for which it is certain that they do not compose with the
property monitor. In addition, although mCRL2 offers direct model checking
with $\mu$-calculus and can provide feedback when the property fails to hold, this
feedback is not at the level of the mCRL2 process specification.
Using the monitor, the counter-example will be provided at the UML level.
\vspace{-10 pt}

\subsection{Transforming a $\mu$-calculus Formula Into a Monitor Process} 
\vspace{-7 pt}

A general model checking mechanism used with tools like SPIN 
is to construct a B\"uchi automaton for an LTL formula, which accepts exactly those executions
that violate the property. A product of the model state space (typically a Kripke structure) and the B\"uchi automaton is then composed, 
and checked for emptiness. 
Although syntactically B\"uchi is similar to the finite-state monitor for which we aim,
the difference lies in the acceptance conditions: a monitor accepts only 
finite runs of the system, while B\"uchi can trap infinite executions through
detection of cycles, but potentially needs the entire state-space
generated in the process. Runtime verification
does not store the entire state space of a model, so it cannot detect such cycles. 
In addition, to expose state information, transitions in Fig.~\ref{fig:Buchi} are labeled with elementary
propositions rather than actions (notice the $\wedge$ operator). 
As such, we cannot use existing tools for constructing B\"uchi automata with our
approach.
\begin{figure}[!t]
 \centering
\begin{minipage}[!t]{0.5\linewidth}
\includegraphics[width=0.7\textwidth]{./Buchi.png}%
\caption{A B\"uchi automaton~\cite{Bauer:2011:RVL:2000799.2000800}}
\label{fig:Buchi}
\end{minipage}%
\begin{minipage}[t]{0.5\linewidth}
\includegraphics[width=1.0\textwidth]{./PASSlaunch.png}%
\label{fig:PASSlaunch}
\captionof{figure}{Launching PASS from the Eclipse Project Explorer\label{fig:PASSlaunch}}%
% \caption{Launching PASS from the Eclipse Project Explorer}
\end{minipage}
\end{figure}

Not every property can be monitored at runtime when only a finite run has been 
observed so far. Monitorable properties are those for which a violation occurs along a finite execution.
This problem has been studied~\cite{DBLP:journals/corr/abs-1006-3638}, and it is known that the class of 
monitorable properties is strictly larger than the commonly believed class of \emph{safety} properties.
However, an exact categorization of monitorable properties is missing.
In particular, the definition of \emph{liveness} requires that any finite system
execution must be extendable to an infinite one that satisfies the property. 
By defining an end-scope of a property, we can also assert
violations to \emph{existence} patterns, which are typically in the \emph{liveness} category. 
Such runtime monitor can also assert \emph{universality} and \emph{absence} patterns 
with or without scope combinations. We found that we are able to construct 
a monitor for about 50\% of the property patterns.

We translate a fragment of the $\mu$-calculus to mCRL2 processes which
can subsequently serve as an observer processes for monitorable properties.
We restrict to the following grammar:
\[
\begin{array}{ll}
\phi & ::= b \mid \forall d{:}D.\phi \mid [\rho]\phi \mid \phi\wedge \phi\\
\rho & ::= \alpha \mid nil \mid \rho\cdot \rho \mid
              \rho+\rho \mid
              \rho^* \mid \rho^+ \\
\alpha & ::=  a(d_1,\dots,d_n) \mid \neg \alpha \mid b \mid
              \alpha \cap \alpha \mid \alpha \cup \alpha \mid
              \bigcap d{:}D.~\alpha \mid \bigcup d{:}D.~\alpha
\end{array}
\]
Before we present the translation, we convert the formulas in
guarded form. That is, we remove every occurrence of $\rho^*$ and $nil$ using
the following rules:
\[
\begin{array}{ll}
~
[nil]\phi &= \phi \\
~[\rho^*]\phi &= [nil]\phi \wedge [\rho^+]\phi
\end{array}
\]
The function $\Tr$ takes two arguments (a formula and a list of typed
variables) and produces a process. It is defined inductively as follows:
\[
\begin{array}{ll}
\Tr_l(b) &= (\neg b \to \textit{error}) \\
\Tr_l(\forall d:D.\phi_1) & = \sum d{:}D. \Tr_{l\concat [d:D]} (\phi_1) \\
\Tr_l(\phi_1 \wedge \phi_2) & = \Tr_l(\phi_1) + \Tr_l(\phi_2) \\
\Tr_l([\rho]\phi_1) & = \TrR_l(\rho) \cdot \Tr_l(\phi) \\
\end{array}
\]
where $\TrR$ takes a regular expression (and a list of typed variables)
and produces a process or a condition:
\[
\begin{array}{ll}
\TrR_l(\alpha) &= \bigoplus\limits_{a \in Act} (\sum d_a{:}D_a.~ \TrA_l(a(d_a),\alpha) \to a(d_a)) \\
\TrR_l(\rho_1 \cdot \rho_2) & = \TrR_l(\rho_1) \cdot \TrR_l(\rho_2) \\
\TrR_l(\rho_1 + \rho_2) &= \TrR_l(\rho_1) + \TrR_l(\rho_2) \\
\TrR_l(\rho^+) & = X(l) \qquad \textit{where $X(l) = \TrR_l(\rho)\cdot X(l)$ is
a recursive process} 
\end{array}
\]
where $\bigoplus$ is a finite summation over all action names
$a \in Act$ of the mCRL2 process and
where $\TrA$ takes an action and an action formula and produces a condition
that describes when the action is among the set of actions described by
the action formula:
\[
\begin{array}{ll}
\TrA_l(a(d_a),a'(e)) & = \left \{ \begin{array}{ll} d_a = e & \text{if a = a'}\\
                                  \text{false} & \text{otherwise}\\
                                  \end{array} \right .\\
\TrA_l(a(d_a),b) & = b \\
\TrA_l(a(d_a),\neg \alpha) & = \neg \TrA_l(a(d_a),\alpha) \\
\TrA_l(a(d_a),\alpha_1 \cap \alpha_2) & =
\TrA_l(a(d_a),\alpha_1) \wedge \TrA_l(a(d_a),\alpha_2) \\
\TrA_l(a(d_a),\alpha_1 \cup \alpha_2) & =
\TrA_l(a(d_a),\alpha_1) \vee \TrA_l(a(d_a),\alpha_2) \\
\TrA_l(a(d_a),\bigcup d{:}D.~\alpha) & = \exists d{:}D.~ \TrA_l(a(d_a),\alpha)\\
\TrA_l(a(d_a),\bigcap d{:}D.~\alpha) & = \forall d{:}D.~ \TrA_l(a(d_a),\alpha)
\end{array}
\]
Using the above translation, Fig.~\ref{fig:ResponsePattern} shows monitor visualization next to the sequence diagram for the chain response pattern.
Such a monitor can be placed in parallel a the system model,
to perform runtime verification. Clearly, in the ``worst'' case, if the model is correct with respect to the property,
all relevant model states will be traversed. In practice however, refutation can be found 
quickly after a limited exploration. 
\vspace{-7 pt}

\section{Case Study: DIRAC's Executor Framework revisited}
\vspace{-6 pt}

DIRAC \cite{DIRAC_CommGridSolution} is the grid framework used to support production activities of the LHCb experiment at CERN.
All major LHCb tasks, such as raw data transfer from the experiment's detector to the grid storage, data processing, and user analysis,
are covered by DIRAC. 
Jobs submitted via its interface undergo several processing steps between the moment they are submitted to the grid, 
to the point when their execution on the grid actualizes. 

The crucial Workload Management components responsible for orchestrating this process are the \emph{ExecutorDispatcher} and 
the \emph{Executors}. Executors process any task sent to them by the ExecutorDispatcher, each one being responsible for a different step in the handling of tasks
(such as resolving the input data for a job).
The ExecutorDispatcher takes care of persisting the state of the tasks and distributing them amongst all the Executors, based on the
requirements of each task. It maintains a queue of tasks waiting to be processed, and other internal data structures to keep track
of the distribution of tasks among the Executors.
During testing, certain problems have manifested: occasionally, tasks submitted in the system would not get dispatched, despite the fact that their responsible Executors
were idle at the moment. The root cause of this problem could not be identified by testing  with different workload scenarios, nor by analysis of the 
generated logs. 
In~\cite{DBLP:dblp_conf/nfm/RemenskaTWHVCB13} we manually formulated this problem as the following safety property:
\begin{lstlisting}[basicstyle=\sffamily\fontsize{7}{7}\selectfont,showspaces=false,showstringspaces=false,showtabs=false,mathescape]
[true$^*$ .
synch_call(1,ExecutorQueues,$\underline{\hspace*{7pt}}$queues,pushTask(JobPath,taskId,false)).
true$^*$.
!(synch_call(1,ExecutorQueues,$\underline{\hspace*{7pt}}$queues,popTask([JobPath])))$^*$.
synch_reply(1,ExecutorDispatcher,$\underline{\hspace*{7pt}}$eDispatch,
$\underline{\hspace*{7pt}}$sendTaskToExecutor_return(OK,0))]false 
\end{lstlisting} 
\vspace{-5 pt}

, meaning that a task pushed in the queue must be processed, i.e., removed from the queue before the ExecutorDispatcher
declares that there are no more tasks for processing.
Explicit model checking was not feasible in this case due to the model size (50 concurrent processes),
so we resorted to writing a standard monitoring process set to run in parallel with the original model.
With a depth-first traversal in mCRL2, we effectively discovered a trace~\cite{repo:remenska} violating the property within minutes, and
used our tool to import and automatically visualize the counter-example as a sequence diagram in RSA.
Since the bug was reported and fixed, we wanted to check if the problem still persists after the fix, this time using PASS to 
elicit the property.
\vspace{-7 pt}

\label{sec:CaseStudy}
\subsection{PASS: The Property ASSistant} 
\vspace{-5 pt}

To cope with the ambiguity of system requirements, PASS 
guides the practitioner via a series of questions to distinguish the types of scope and 
behavior as a relation between multiple events. By answering these questions, 
he is lead to consider some subtle aspects of the property, which are typically 
overlooked when manually specifying the requirement in temporal logic.
The last part of the property (i.e. ``before the ExecutorDispatcher
declares that there are no more tasks for processing'') is easily recognized as a scope restriction,
which the user can choose by selecting the appropriate answer from the Scope Question Tree wizard page.
\begin{figure}[!t]
\centering
{%
\setlength{\fboxsep}{1.5pt}%
\setlength{\fboxrule}{0.5pt}%
\fbox{\includegraphics[width=1.0\linewidth,keepaspectratio=true]{./ScopeSelection1.png}}%
}%
\caption{Eliciting the scope for a property with PASS}
\label{fig:ScopePASS}
\end{figure}
This results in a \emph{Before-R} scope restriction, where the actual communication can be selected by double-clicking the end-event placeholder (Fig.~\ref{fig:ScopePASS}).
This presents the user with a popup window with all the possible message exchanges in the model, so he can choose the actual message, in this case
the reply message $\_\_sendTaskToExecutor$.
As already pointed out in~\cite{Smith02propel:an}, a closer examination of the patterns classification reveals some aspects
which are not considered, and may lead to variants in the original scope and behavior definitions. 
For example, the definition of the \emph{Before-R} scope requires that the event \emph{R} necessarily
occurs. This means, if \emph{R} does not occur until the end of the run, the intent or behavior 
of the property could be violated, yet the property as a whole would not be violated 
unless \emph{P} happens. In practice however, it is useful to introduce an \emph{Until-R} variant for cases where the end-delimiter may not occur until the end of 
the system execution. This is captured by the last question in Fig.~\ref{fig:ScopePASS}.
Similar considerations have lead to new variants of the \emph{After-Q-Until-R} and \emph{After-Q-Before-R} patterns.
For instance, whether subsequent occurrences of Q should be ignored, or should effectively reset the beginning of the interval
in which the behavior is considered, are reflected in the questionnaire.

Due to space restrictions we do not show the Behavior Question Tree part of the wizard, although it is easy to
elicit the behavior requirement as a \emph{response} pattern (``a task \emph{pushed} in the queue must be processed, i.e., \emph{removed} from the queue'').
The actual events of interest in this case are \emph{pushTask} and \emph{popTask}. Again, an extension of the pattern system allows
for the user to decide whether the first event (the cause) must necessarily occur in the first place. 
Adding 4 scope and 2 behavior variations have lead to more than 100 ((5+\textbf{4})$\ast$(11+\textbf{2})) new unique patterns to be chosen from. 

At the end of the questionnaire, the user is presented (Fig.~\ref{fig:Summary}) with with a summary of the requested property, which can be reviewed before making the final decision.
A $\mu$-calculus formula pertaining the property is presented, along with the possibility to assign concrete parameter values that messages carry. 
Since the property should be evaluated for all possible values of the taskId's domain, a wildcard ``*'' can be used (as shown in the \emph{pushTask} message's second parameter).
This assignment results in a formula with a \emph{forall} quantifier. In addition, a sequence diagram (Fig.~\ref{fig:SDProperty}) and a monitor process (visualized in Fig.~\ref{fig:MonitorProperty}) the concerned property 
are generated, to be used in the final model checking phase.
\begin{figure}[!t]
\centering
{%
\setlength{\fboxsep}{1.5pt}%
\setlength{\fboxrule}{0.5pt}%
\fbox{\includegraphics[width=1.0\linewidth,keepaspectratio=true]{./Last.png}}%
}%
\caption{Summary of the elicited property with PASS}
\label{fig:Summary}
\end{figure}
One thing worth noticing is the fact that our original manually constructed formula was not entirely correct, and as such could potentially produce spurious counter-examples. 
The general pattern template obtained with PASS is:
\begin{lstlisting}[basicstyle=\sffamily\fontsize{7}{7}\selectfont,showspaces=false,showstringspaces=false,showtabs=false,mathescape]
[(not R)$^*$. P. (not (S or R))$^*$. R] false
\end{lstlisting} 
, which puts more restrictions on the behavior, while the original one was of the following form:
\begin{lstlisting}[basicstyle=\sffamily\fontsize{7}{7}\selectfont,showspaces=false,showstringspaces=false,showtabs=false,mathescape]
[true$^*$. P. (not S)$^*$. R] false
\end{lstlisting} 

Using the generated monitor, we performed runtime verification on the corrected model with the mCRL2 toolset.


\begin{figure}[!b]
 \centering
\begin{minipage}[!t]{0.5\linewidth}
\includegraphics[width=0.9\textwidth]{./Buchi.png}%
\caption{A monitor for the property}
\label{fig:MonitorProperty}
\end{minipage}%
\begin{minipage}[t]{0.5\linewidth}
\includegraphics[width=0.9\textwidth]{./SDProperty.png}%
\label{fig:PASSlaunch}
\captionof{figure}{An sequence diagram depicting the property\label{fig:SDProperty}}%
\end{minipage}
\end{figure}
\vspace{-7 pt}

\section{Conclusions and future work}
\label{sec:Conclusions}
\vspace{-7 pt}

%compositional patterns
\bibliographystyle{splncs} 
\bibliography{FM2014}
\end{document}


